
------------
SYMFONY
------------

Yakine HAMIDA
yakine.hamida@evogue.fr 

-------------

notions:
MVC = model view controller , model pour la base de donn√©e, view pour les pages , 

-------------

1/ R√©visions PHP OO :

Visibilit√© - Autoload - Namespace - Interface

(par default, une propriet√© sans precision sur sa visibilit√© sera consider√©e public)

-------------
2/
SYMPHONY:

-intro: qu'est-ce que SYMFONY
√©tape 1 : installation de symfony 3.4
√©tape 2 : les bundles
√©tape 3 : les routes et mles controllers
√©tape 4 : Cr√©er la boutique sur SYMFONY
√©tape 5 : TWIG (moteur de template)
√©tape 6 : les assets
√©tape 7 : Entit√©s
√©tape 8 : Doctrine
√©tape 9 : les formulaires
√©tape 10 : validation des donn√©es
√©tape 11 : Association Mapping 
√©tape 12 : s√©curit√© des utilisateurs
√©tape 13 : installation et boutique sur SF 4.3
BONUS : Mise en ligne
BONUS : Formulaire de contact
BONUS : Panier

-----------------

                                                                      ------------------------------
                                                                       intro: qu'est-ce que SYMFONY
                                                                      ------------------------------

Framework php cr√©√© par Sensiolabs en 2005

a - quel est l'interet d'utiliser un framework:
    1- une organisation optimis√©e
    2- Fonctionnalit√© communes a tous les projets
    3- Services disponibles (Routing, Securit√©, BDD, Moteur de template, formulaire...)
    4- Communaut√© 

b - choix du Framework
    1- propre framework (pedagogie)
    2- Les framework fullstack(Symfony, Zend, Laravel, Cake)
    3- Les mini framework (Silex, Slim, CodeIgniter, Lumen...)

c - Symfony 
    -->Framework fran√ßais cr√©√© par Sensiolabs
    -->versions: 
        LTS (long time support): 
            v 2.8
            v 3.4 : 2.8 mais plus souple, avec des fonctionnalit√©s
            v 4.4 : 3.4 Bundleless, Flex, Ecore (webpack), maker, php 7.1

                                                                --------------------------------------
                                                                 √©tape 1 - Installation de Symfony 3.4           
                                                                --------------------------------------

1 - installer Composer
2 - installer sf3.4
3 - Arborescence des dossiers et fichiers
4 - Lancement de l'settings_applications

-------->

1- Composer est un outil de d√©pendance, il permet de telecharger et de mettre a jour tous les outils, (services, composants, dependances..) dont on a bluetooth_searching
telecharger composer: http://getcomposer.org/download/composer-setup.exe 
installer puis suivre les √©tapes

2- installer symfony 3.4
On va dans le dossier Symfony, 'maj' + 'clic droit' puis ouvrir l'invite de commande (powershell, ou git bash here) ici.

en ligne de commandes: composer create-project symfony/framework-standart-edition test

3- Arbrescence des dossiers et fichiers
        dossiers:
        - app/               : contient toutes la configuration de l'app (BDD, securit√©, routes...)
        - bin/               : les executables de l'app (donc de sf)                   
        - src/               : Le dossier dans lequel nous allons coder notre MVC (c'est ici que l'on va coder 99% du temps)
        - var/               : les fichiers √©crits par sf au fur et a mesure (cache, logs)
        - tests/             : Les tests unitaires.
        - web/               : repertoire web (app.php ou app_dev.php, equivalent de index.php pour symfony)
        - vendor/            : Le coeur de Symfony, (les fichiers cod√©s par les sensio labs)
        
        fichiers:  
        - composer.json      : Contient la liste de toutes les dependances dont on a besoin.

4 - Lancement de l'application

        methode 1 :
        Localhost/back/wf3/symfony/test/web/app.php
        Localhost/back/wf3/symfony/test/web/app_dev.php (affiche une petite barre de develkoppement en bas)

        methode 2 :
        on va dans le dossier test/ et en ligne de commande:
        php bin/console server:run

        puis dans le navigateur, localhost:8000  (par defaut on est en mode dev, avec la barre de dev en bas)

        -nous allons travailler en mode dev, avant de passer en mode prod
        - √† ce stade notre application affiche la page de bienvenue sur Symfony, cela signifie que tout va bien 

                                                                --------------------------------------------
                                                                            √©tape 2 : les bundles
                                                                --------------------------------------------     

1/ Le concept des bundles

   - Les bundles sont des briques de notre application (des modules)

   par exemple: 
                Userbundle:
                        UserController (C)
                        UserModel (M)
                        View : inscription/connexion/profil...

  Avec la nouvelle version de Symfony (4), on considere qu'il est pr√©ferable de cr√©er un seul bundle (AppBundle) , auparavant on fonctionnait par bundle, un dossier par brique et nos fichiers mvc a l'interieur
  Nous allons cr√©er un bundle: POLES/TestBundle

        en ligne de commandes, on va taper (au choix soit dans notre dossier de projet, soit dans le terminal de VCstudio) 
  <cmd>     
        - php bin/console generate:bundle     
        - Are you planning on sharing this bundle across multiple applications? [no]: on met yes ou 'y' pour creer un bundle    
        - nous cr√©erons un bundle POLES/TestBundle (donc un nameSpace)
        - le creer dans les dossier src? on tape enter
        - configuration format: on va choisir: annotation
        (notre bundle a √©t√© cr√©√© mais il faut l'enregistrer dans composer.json)
        - on ouvre dans notre ide, le fichier composer.json, puis dans psr-4 on rajoute une virgule apres appBundle, puis: "POLES\\":"src/POLES"
        - puis dans le terminal: composer update   

A present notre bundle existe dans src/POLES/TestBundle
        il est compos√© de 4 dossiers: -controller : tous les controller du bundle 
                                      -DependencyInjection : injection de dependances 
                                      -Resources : Vues et Routes (YML) et eventuellement JS 
                                      -Test : test li√©s aux fonctionnalit√©sdu bundle

A ce stade le bundle est fonctionnel, mais il y'a une petite erreur, qu'on va corriger:
        nous allons dans : src/POLES/TestBundle/Controller/DefaultController.php
        puis a la ligne: return $this->render('POLESTestBundle:Default:index.html.twig'); 
        on la r√©√©crit comme ceci:  return $this->render('@POLESTest/Default/index.html.twig');    

        apres avoir corriger la syntaxe, on voit apparaitre la page d'accueil 'Hello World'.                                 

                                                                -----------------------------------------------------
                                                                       √©tape 3 : les routes et mles controllers
                                                                -----------------------------------------------------

1/ cr√©ation de routes

        ("/") -> route simple homepage
        ("/bonjour/") -> route echo (erreur)
        ("/bonjour2/") -> route response
        ("/hello/{prenom}") -> route response + param URL
        ("/hola/{prenom}") -> route render de vue (html.twig) + param URL
        ("/ciao/{prenom}/{age}") -> route render de vue + 2 params URL
        ("/redirect/") -> route avec redirection (RedirectResponse)
        ("/redirect2/") -> route avec redirection (redirectToRoute())
        ("/message/") -> route avec redirect et message en session



2/ L'objet Request

        L'objet Request correspond a la partie request d'une requete http        

        <code>
              use Symfony\Component\HttpFoundation\Request;
              correspond a la partie 'requete' d'une requete http

        <ex code>
        $session $$request->getSession();
        recupere la session ($_SESSION)

        Autres exemples: 

        $session->set('prenom', 'Sylvain');
        echo $session->get('prenom');

        $request->session->set('prenom', 'Sylvain');

        Autre utilit√© de $request: 

        $request ->query->get('argument_url');
        $request ->request->get('champs_form');
        $request ->cookies->get('cookie');
        $request ->server->get('infos_serveur');

3/ L'objet Response

        L'objet Response correspond a la partie reponse d'une requete http

        <code>
                use Symfony\Comonent\HttpFoundation\Response;

                Toute action (fonction) doit avoir une r√©ponse.

                return new Response('toto');

                meme la fonction render() est une r√©ponse.

                <code>
                return $this->render();
                return $this-> getTemplateting->renderResponse(); 
                cette derniere ligne fait la meme chose que celle juste au dessus

4/ Redirection

        <code> premiere methode :
        Use Symfony\Component\HttpFoudation\RedirectResponse;

        se referer √†: route "/redirect/" et "/redirect2/"

        /!\ A ce stade toutes nos routes doivent avoir un name

5/ Message

        <code>

        $session->getFlashBag()->add;

        permet d'enregistrer des messages qui seront disponibles dans d'autres pages (messages de felicitation , ou d'erreurs)

        app.session : qui nous permet en twig de recuperer les infos en session

        app.user : qui nous permet en twig de recuperer les infos de l'utilisateur actuellement connect√©s


                                                                -----------------------------------------------
                                                                    √©tape 4 : Cr√©er la boutique sur SYMFONY
                                                                -----------------------------------------------   

1/ Cr√©aion du projet   

        -dans le dossier symfony
        <cmd>
                composer create-project symfony/framework-sandard-edition Boutique3
                cd boutique3
                php bin/console server:run

        Test : localhost:8000        

2/Reorganiser le AppBundle

        A ce stade, on a cr√©√© 3 routes dans ProduitController:
                localhost/                  ---> index.html.twig
                localhost/categorie/pull    ---> index.html.twig
                localhost/produit/12        ---> show.html.twig

        -> creation de nos controllers:
                AdminController
                MembreController
                CommandeController
                ProduitController

        -> cr√©ation de nos vues 
                Admin/ (list_produit, form_produit etc...)
                Membre/ (connection, inscription, profil ...)
                Commande/ (panier, transport, livraison, paiement...)
                Produit/ (home, categorie, boutique, fiche_produit...)

3/ cr√©ation des premieres routes

        --> ProduitController: "/", "/produit/{id}/" etc...
        --> AdminController : "/admin/produit/", "/admin/membre/" etc...

                                                               ----------------------------------------------
                                                                     √©tape 5 : TWIG (moteur de template)
                                                               ----------------------------------------------     

Twig est le moteur de template de Symfony, un moteur de template(tpl, smarty, Twig, blade...) permet d'afficher du php dans les vues HTML de maniere plus simple
        exemple : au lieu d'afficher du php comme ceci <?= $membre['prenom']?>, en twig cela donnera {{membre.prenom}} 
       
1/ creation du layout 

        un Layout est une structure de page, dans laquelle on peut ajouter des √©l√©ments/ du contenu. Le concept des layout permet d'avoir plusieurs structures de pages dans notre site: exemple front et backoffice. pourtant c'est le meme site.

    - dans SF 3.4 , on a un endroit specifique ou il faut mettre le layout (dans app/Resources/views)

       chemin(pour notre projet): Boutique3/app/Resources/views/layout.html.twig

2/ L'heritage twig 

        Avec Twig, on parle d'heritage, cela signifie que nos vue heritent (extends) d'un layout. et peuvent contenir de l'HTML √† l'interieur des blocks disponibles (cr√©√©s dans le layout).

        De maniere generale, il faut voir le fonctionnement de Twig et de la methode render comme un chargement de contenude maniere "empil√©e" (analogie de la poup√©e russe...)
        . Render temporise (m√©moire tampon) le contenu et affiche en meme temps l layout, la vue et les params.

3/ modification de nos vues

        <code>
        {% extends 'layout.html.twig %}
        {% block content %}
        Contenu HTML de la page
        {% endblock %}

        /!\ Attention, quand on utilise l'heritage Twig, nos vues ne peuvent contenir de l'html qu'a l'interieur des blocks prevus pour


4/ Documentation twig

        https://twig.symfony.com/doc/2.x/

        Dans les twigs r√©f√©rence, on trouve dans les filtres ce qui permet de formater l'ecriture, les dates, majuscules, conditions, securit√©s... dont on se servira dans nos projets.

------> A ce stade, notre application permet d'afficher les pages, accueil, inscription, connexion, profil, botique, produit, categorie, gestion membre, gestion produit, gestion commande. 

------> Par contre nous ne sommes pas encore en mesure d'echenger avec la base de donn√©e (ajouter du contenu, et afficher ce contenu). Il faut voir les entit√©s et Doctrine.


                                                                        -------------------------------
                                                                                √©tape 6 : ASSETS
                                                                        -------------------------------

        Le composant assets de symfony permet de gerer les ressources dans le dossier web(photo, img, js, fonts, css...) et de les appeller de maniere absolue,la fonction asset redirige toujours vers notre dossier web

1/ Modification du fichier composer.json

        <code> (dans composer.json)
        "require": ("symfony/asset" : "^3.4")         le "^3.4" signifie sert toi au minimum de la version 3.4, pas en dessous 
        
2/ Mise a jour de l'app

        <cmd>
        composer update

3/ Dossier web/ (photos, css, js...)

        boutique3/web/
                photo/ (creer ces 3 dossiers)
                css/
                js/


4/ Modifications des vues

        En php procedural, notre lien css, nous le mettions comme ceci
        href="../../css/style.css"

        avec la fonction asset() , nous procederons comme ceci: 
        href="{{ asset('css/style.css') }}"

        avec la fonction path(), nous ferons un lien vers une page: path('nomderoute')

        -----
        Liens dynamiques: 

        En procedural, nous aurions fait pour nos photos:
        src="../../photo/<?= $pdt['photo'] ?>"

        en symfony:
        src="{{ asset('photo/' ~ pdt.photo) }}"


        href="{{ path('produit', {'id':pdt.id} ) }}"



                                                                        -------------------------------
                                                                                √©tape 7 : ENTITES
                                                                        -------------------------------

1/ Doctrine ORM et le concept des Entit√©s (Entity)

        -D'une certaine maniere, les entit√©s correspondent a la partie model de notre MVC, c'est la relation avec la bdd, mais en PHP et non en SQL.
        Theoriquement, nous n'aurions plus besoin du SQL a partir de maintenant.

        -ORM: Object Relation Mapping 

        -Nous allons cr√©er nos entit√©s sous forme de class PHP (POPO : Plain Old PHO Object) qui vont permettre √† Doctrine de comprendre notre base de donn√©e et de la manipuler.

        -Par exemple : pour faire INSERT INTO Produit, on fera $produit = new Produit;
                                                               persist($produit);  pour ajouter, si on voulait supprimmer, ce seraitremove a la place de persist
        
        Pour que tout cela soit possible il faut expliquer a Doctrine quelle relation il existe entre la BDD et nos Entity

2/ Cr√©er Entit√© produit

        a- Creer le dossier Entity dans src/AppBundle/

        b- Creer le fichier Produit.php : src/AppBundle/Entity/Produit.php

        c- Creer notre class Produit et nos propriet√©s

3/ Annotations (mapping)

        Avec Doctrine ORM, on parametre le mapping via les Annotations
                <code>
                use Doctine\ORM\Mapping as ORM   
                (voir le fichier Entity/Produit.php)

        /!\ Attention: Les annotations pour l'id (primary key) sont plus longues
        exemple: <code>
                /**  
                * @ORM\Column(name="id_produit", type="integer", nullable=false)
                * @ORM\Id
                * @ORM\GeneratedValue(strategy="AUTO")
                */

        Liens: 
        Basic Mapping:
        https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html  

        Association Mapping:
        https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html  

            
4/ Mettre a jour la BDD

        <cmd>
        pour voir la requete et donc voir ce qui va etre modifi√© en base de donn√©e:
        php bin/console doctrine:shema:update --dump-sql

        si c'est bon, on a ce qui ressemble a une requete sql, si on a des erreurs il faut

        puis pour executer les modifications:
        php bin/console doctrine:shema:update --force

        force permet de creer une BDD a partir de nos Entit√©s

        

5/ Generer les Entit√©s en ligne de commande

        A- on doit connecter notre app(notre projet symfony) √† la BDD, dans le fichier suivant: (attention, le fichier parameters.yml est dans le .gitignore, comme le vendor, il faut donc faire un composer update quand on recupere le symfony chez soi)
         app/Config/parameters.yml

                parameters:
                        database_host: localhost
                        database_port: 3306
                        database_name: boutique
                        database_user: root
                        database_password: 
                        mailer_transport: smtp
                        mailer_host: 127.0.0.1
                        mailer_user: null
                        mailer_password: null
                        secret: ThisTokenIsNotSoSecretChangeIt


        B- php bin/console doctrine:generate:entity

        si tout se passe bien, un message bleu apparait "Welcome to the Doctrine2 entity generator", puis il nous demande d'entrer: The Entity shortcut name:

        pour cr√©er notre table directement avec les setter et getteur automatiquement:
        <cmd>
                AppBundle:Membre
               --> on suit les √©tapes
               cela nous a gener√© le fichier Entity/Membre.php en quelques lignes de commandes.

6/ Generer mes Entit√©s via les Entit√©s

        on peut creer la BDD, depuis les Entit√©s deja cod√©es

        on peut cr√©er les tables dans la BDD, Par contre il faut que la BDD existe deja
        <cmd>
        php bin/console doctrine:shema:update --force


7/ Generer les Entit√©s depuis la BDD    

        On peut aussi cr√©er des Entit√©s depuis la BDD

        <cmd>
        php bin/console doctrine:mapping:import AppBundle\Entity annotation --path=src/AppBundle/Entity       

        Cette commande nous a permis de generer les Entit√©s depuis les tables de la BDD, par contre cela ne nous a ni gener√© les Repository, ni les setter et getter
        on a ajout√© dans chaque Entity: 

        @ORM\Entity(repositoryClass="AppBundle\Repository\CommandeRepository")
        @ORM\Entity(repositoryClass="AppBundle\Repository\ProduitRepository")
        @ORM\Entity(repositoryClass="AppBundle\Repository\DetailsCommandeRepository")
        @ORM\Entity(repositoryClass="AppBundle\Repository\MembreRepository")

        √† present en ligne de commande , nous allons cr√©er les setter et getter et generer les repository (dans notre dossier AppBundle\Repository\ on aura √©galement les memes fichiers repository en double avec un '~' , c'est une sauvegarde de notre ancien fichier, avant qu'il cr√©√© les setter et getteur, on est pas oblig√© de le garder si pas de nessecit√©): 

        <cmd>
        php bin/console doctrine:generate:entities AppBundle

                                                                        ----------------------------------
                                                                                √©tape 8 : DOCTRINE
                                                                        ----------------------------------

1/ Le service Doctrine

        Doctrine fait 2 choses:

                1/ORM (Object Relation Mapping)
                Il permet de lier les tables de notre BDD √† nos Entit√©s. On ne va pas manipuler la BDD, mais des objets(la table Produit ---> Entity Produit)

                2/ Doctrine DBAL (Database Abstract Layer)
                Le DBAL est une couche qui passe au dessus de PDO. A partir de maintenant, on ne fait plus de SQL, mais on va manipuler du PHP. Il va nous permettre de faire du SELECT, INSERT, DELETE en DQL (Doctrine Query Language) en opposition au SQL(Structure Query Language)

                Nous ne ferons plus de SQL ou presque

2/ Acceder au service doctrine depuis les controllers  

        a- Il faut pouvoir manipuler les entites dont on a besoin


3/Requetes SELECT * FROM ...

        Depuis le Repository:
        <code>
        $repo = $this->getDoctrine()->getRepository(Produit::class);
        $produits= $repo->findAll();


4/Requetes SELECT * FROM ... WHERE id =

        2 methodes:

        Depuis le Repository:
        <code>
        $em =$this->getDoctrine()->getRepository(Produit::class);
        $produit = $em->find(Produit::class);

        Depuis le Manager:
        $em =$this->getDoctrine()->getManager();
        $produit = $em->find(Produit::class, $id);


5/Requetes SELECT * FROM ... WHERE ... = ...

        La fonction findBy() va nous permettre de recuperer des donn√©es de maniere plus cibl√©e.
        <code>
        $repo =$this->getDoctrine()->getRepository(Produit::class);
        $produit = $repo->findBy(array('categorie'=>$cat));
        $produit = $repo->findBy(array('taille'=>'1'));

        SELECT * FROM produit WHERE taille = '1' AND categorie = 'tshirt'

        -pour selectionner les produits de couleur rouge, par prix decroissant, affichant les resultats de 1 √† 10 (pour la pagination, par exemple page 2 ce serait 'DESC'], 20,10):
        $produit = $repo->findBy(['couleur' => 'rouge' ] , ['prix' -> 'DESC'], 0,10);
        SELECT * FROM produit WHERE couleur = 'rouge' ORDER BY prix DESC LIMIT 0, 10

        -pour sectionner le premier des produits:
        $produit = $repo->findOneBy(array('taille'=>'1'));
        SELECT * FROM produit WHERE taille = '1' LIMIT 0,1


6/Requetes INSERT / update

        Avec Doctrine on manipule des objets de notre class Entity. 
        On preferera passer via le Manager pour faire les requetes, car persist et flush ne fonctionne pas avec EntityRepository, mais avec le Manager.

        -Enregistrement: on cr√©√© un objet vide, 
                        on hydrate (normalement via le formuaire), 
                        puis on persiste et on flush (on enregistre et on envoie la requete)

                        <code>
                        $produit = new Produit;
                        $produit->setTitre('dsfbqdbqdb');
                        $produit->setReference('sdfgdfg');

                        $em->persist($produit);
                        $em->flush();

        -Modification:
                        Pour update une Entit√©, c'est le meme processus que pur add, a ceci pres que l'objet n'est vide a la base, on doit donc d'abbord recuperer l'objet a modifier avec la fonction find()   
                              

7/Requete delete

        Avec Doctrine on manipule des objets de notre class Entity., donc on va d'abord recuperer l'objet avec la fonction find()

        <code> 
        $em->remove($produit);
        $em->flush();


8/Create Query et Query Builder

        Pour effectuer des requetes specifiques, nous avons 2 possibilit√©s :

        -Create Query (SQL)
        -Query Builder

        ---> voir ProduitRepository

        /!\ Dans l'objectif de "factoriser" le code, nous cr√©ons nos requetes specifiques dans le Repository, afin de les utiliser de maniere simple dans les controller.

        ---> voir le ProduitController,  route "/categorie/" et la fonction getAllCategories() declar√©e dans le ProduitRepository:

        Liens:

        Create Query : 
	https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/dql-doctrine-query-language.html

        Query Builder:
        https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html
	
	
                                                                    ----------------------------------
                                                                        √©tape 9 : Les formulaires
                                                                    ----------------------------------


1/ Le fonctionnement des formulaires

        De la meme maniere qu'on ne manipule pas des enregistrements en bdd, mais bien des objets (entity) chaque formulaire va etre li√© √† une entit√©s

        Ainsi un formulaire est li√© √† un objet...

        Inscription ==========> Objet membre
        Ajout de produit======> Objet Produit
        Modif de produit======> Objet Produit
        ajout d'une commande==> Objet Commande

        Un formulaire est gener√© grace √† une class (type --> ProduitType)
        Chaque champ d'un formulaire correspond √† une class, service de SF, cela permet de generer tous les controles sur les formulaires.

2/ Generer les formulaires

        <cmd>
                php bin/console generate:doctrine:form AppBundle:Produit 

        ---> cela cr√©√© un dossier Form dans notre Bundle, et un fichier ProduitType.php, qui contient la construction du formulaire.        


3/ Recuperer les donn√©es du formulaire (Traitement du formulaire)

        A- Generer le formulaire dans la route

                <code>
                use AppBundle\Form\ProduitType
                $form = $this->createForm(ProduitType::class, $produit);     

        B- Afficher le formulaire dans la vue

                -on envoi le formulaire √† la vue via les params:

                <code>
                $params = array('produitForm' -> $form -> createView())

                - on affiche le formulaire:
                <code>
                {{form_label(produitForm.reference)}}---->affiche le label
                {{form_widget(produitForm.reference)}}---->affiche le champ
                {{form_errors(produitForm.reference)}}---->affiche les erreurs

                /!\ Si on affiche les champs un par un, il ne faut pas oublier:
                        {{ form_start(produitForm) }}
                        {{ form_end(produitForm) }}



        C- Recuperer les donn√©es saisies

                $form->handleRequest($request);
                /!\ Cette ligne est tres importante pour pouvoir recuperer les donn√©es en POST

        D- Checker la validit√© du form et traiter les donn√©es (enregistrement)

                <code>
                if($form->isSubmitted() && $form-> isValid())
                {
                        //persist
                        //flush
                        //message de validation
                        //   
                }       

4/ Personnaliser un formlaire avec Bootstrap

        -Dans: app/Config/config.yml
        <code>
        (rajouter dans les parametres twig:
                form_themes:
                        - 'bootstrap_4_layout.html.twig

5/ Update un Enregistrement

        Pour update un enregistrement avec le systeme des formulaires sur SF, rien de plus simple. Lorsqu'on cr√©√© le formulaire dans la route, on precise un objet deja existant (voir route admin/produit/update/{id})

        ----> On dit qu'on hydrate le formulaire

6/ Validation des donn√©es

        De base le formulaire est gener√© de maniere 'basique', Pour gerer nous meme les contraintes et la securit√©, cela se passe dans le fichier ProduitType.php et on utilise 'constraints' pour definir les contraintes li√©es au formulaire (voir le fichier ProduitType.php dans le fichier 'Form' que SF a gener√©)

        Pour en savoir plus, tapper 'asserts symfony' sur google (les asserts = les validations)

7/ Champs file

        Pour la gestion de la photo il faut: 
                1/Enregistrer le nom de la photo dans la BDD
                2/Enregistrer la photo (data) sur le serveur.
           (voir la fonction uploadFile dans l'entity Produit)   
        /!\ Dans notre formulaire d'ajout produit, il n'est plus necessaire d'avoir le champs photo (TEXT) mais bien un champs file (FILE) qui va recuperer les infos de la photo upload√©e        

        * Pour aller plus loin dans les formulaires et Symfony:
        https://symfony.com/doc/current/reference/forms/types.html


exo a faire:  inscription

1/ entity Membre
2/ Controller 
3/ Formulaire (MembreType) ---> via la console
4/ Route: Creer le formulaire et sa vue
5/ La vue, Afficher le formulaire
7/ Route: Recuperer les infos du formulaire et enregistrer le membre.

Attention: Etant donn√© que le champ Statut existe dans notre BDD, le formulaire va etre creer avec un champ Statut, hors ce n'est pas au membre de choisir son statut
---------------

                                                        -----------------------------------------------
                                                          √©tape 10 : validation des donn√©es (Asserts)
                                                        -----------------------------------------------

        * Pour aller plus loin dans la validation des donn√©es (les Asserts)
        https://symfony.com/doc/current/validation.html


                                                               --------------------------------
                                                                Etape 11 : ASSOCIATION MAPPING
                                                               --------------------------------
Sommaire : 
1/ Le concept
2/ La Documentation de Doctrine
3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande 
-----------------------------

1/ Avec Doctrine, on a pris l'habitude de travailler avec des objets (Entity) correspondant aux enregistrements dans la BDD (Mapping).

L'association Mapping nous permet de travailler avec des objets dans des objets. Exemple : Un membre peut avoir plusieurs commandes, dans ce cas, dans un objet Membre nous avons un array compos√© d'objets commande. Une commande appartient √† UN membre, dans ce cas dans un objet Commande nous avons un objet membre. 

Gr√¢ce √† ce fonctionnement il est plus n√©cessaire de faire des requ√™tes de jointure, lorsqu'on r√©cup√®re un objet, on r√©cup√®re tous les objets li√©s. 

2/ 
https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html#association-mapping


3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande
	
		-> Entity Membre
		-> Entity Commande

		
		-> Dans la vue list_commande.html.twig, on utilise {{ c.membre.prenom }} pour acc√©der aux infos du membre qui a pass√© la commande. 



                                                        -----------------------------------------------
                                                             √©tape 12 : s√©curit√© des utilisateurs
                                                        -----------------------------------------------   

1/ Niveau de s√©curit√©

      -De base SF va considerer un visiteur lambda comme un anonyme. 

      -Ensuite, On va definir des niveaux de securit√© pour les utilisateurs connect√©s: (chaque niveau de securit√© devra commencer par le mot cl√©:  ROLE)  ex: -ROLE USER  
                 -ROLE ADMIN 
                 -ROLE SUPER_ADMIN 
                 etc...

       - Symfony a un systeme de parfeu (pour definir qui a le droit d'aller ou)
               -on definie les routes que les ROLE peuvent emprunter:
               --> si un user anonyme --> homepage = OK 
               --> si un user anonyme --> profil = pas OK --> redirection: connexion 
               --> si un user connect√© --> profil = OK
               --> si un user connect√© --> admin_produit -> pas OK --> page d'erreur (404) 

               En fonction du visiteur et de la ressource demand√©e, on peut parametrer une reaction

                   
2/ Fichier de securit√©

        dans le fichier: 
        <code>
        app/config/security.yml

        On d√©finie plusieurs choses : 
	- encoders (la mani√®re dont les password seront encod√©s)
	- provider (quelle ressource va servir d'utilisateur : MembreEntity, le login: username)
	- Hierarchie : La pyramide des droits
	- les routes form_login et logout (voir le point suivant)
	- Access control : qui a le droit √† quoi


	/!\ Attention le YAML est tr√®s sensible aux indentations et aux espaces. 


3/ Direction des routes

form_login: 
		login_path: connexion (page de connexion)
		
		check_path: connexion_check (Page de checking de login/password, on doit juste la cr√©√©e, et la mettre dans l'attribut action de notre formulaire de connexion)
		
		default_target_path: homepage (La page par d√©faut sur laquelle on est dirig√© une fois connect√©. Sinon le parefeu prend le dessus)

	logout:
		path: deconnexion (La route de deconnexion. Doit exister mais est vide)
		target: homepage (page de destination, lorsqu'on se d√©connecte). 
		


4/ Classe Membre (extends UserInterface)
	
	- A partir de maintenant la classe Membre doit implements l'interface UserInterface
			
	--> username (getter/setter)
	--> password (getter/setter)
	--> roles (getter/setter) /!\ roles est un array 
	--> salt (getter/setter)
	
	/!\ Attention lors de l'inscription, il faut penser √† d√©finir un role_user par d√©faut. 
	
	--> public function eraseCredentials() : fonction obligatoire pour que SF prenne la main. 
	
	--> getRoles() et setRoles() au pluriel obligatoirement. 


5/ Layout

	Dans les vues on fait la distinction entre le niveau d'acces des utilisateur avec : 
		
	{{ if is_granted('IS_AUTHENTICATED_FULLY') }}  : tout le monde (sauf anonyme)
	{{ if is_granted('ROLE_USER') }}  : tous les users
	{{ if is_granted('ROLE_ADMIN') }}  : tous les admin
		
        ===> Le salage (cf salt.php) c'est l'id√©e de rendre un MDP quasiment inviolable en ajoutant au MDP soit une cha√Æne de caract√®re que seul le d√©veloppeur connait (petit site, petite structure), ou alors une cha√Æne al√©atoire pour chaque user... Ensuite pour la connexion, on r√©cup√®re le salage, pour reconstituer le MDP complet.


                                                               -----------------------		
                                                                ETAPE 13 : Symfony 4		
                                                               -----------------------
Sommaire :
1/ Installation
2/ L'architecture
3/ Lancement de l'app
4/ Le maker
5/ Flex


1/ installation : 
composer create-project symfony/website-skeleton Boutique4

2/ L'architecture

	- app a disparu  ----> config 
	- src/AppBundle a disparu   ---->  BundleLess sans Bundle mais toujours dans le namespace App\
	- src/Resources/ View  a disparu  ---> templates
		
	Le dossier templates prendra toutes les vues (Produit/ Admin/ Membres/ Bases) ainsi que le layout.html.twig
	
	web/ a disparu (app_dev.php, app.php, JS/CSS/Photo) ----> public (index.php, JS/CSS/Photo etc...)
	
	.env : Notre config (notamment les infos de connexion √† la bdd
	
3/ Lancement de l'app

	<cmd>
	php bin/console server:start
		ou alors
	php bin/console server:run
		
		
4/ Le maker : 		

	- Cr√©ation des Entit√©s : 
		php bin/console make:entity
		
		ou depuis la BDD : 
		php bin/console doctrine:mapping:import "App\Entity" annotation --path=src/Entity

			
	- Mise √† jours des entit√©s :
		php bin/console make:Entity --regenerate
		

	- Cr√©er les controller : 
		php bin/console make:controller 
		ProduitController 
		MembreController 
		CommandeController
		BaseController
		AdminController

	- Cr√©er les CRUD : 
		- pre-requis : Copier/coller les entit√©s
		
		copier le dossier	 boutique3/src/AppBundle/Entity
		le coller dans le dossier	boutique4/src/
	
	
		<cmd>
		php bin/console make:crud
		Membre
		Commande
		Produit
		
		
	- Cr√©er l'entit√© Membre : 
		<cmd>
	php bin/console make:user
	
			
Bundle : 

	- FOSUserBundle 
	- easyAdmin 
	

Flex : 

Symfony Flex : la nouvelle fa√ßon de d√©velopper avec Symfony
Les versions de Symfony 3.4 et 4.0 viennent tout juste de sortir et avec elles vient une nouvelle fa√ßon de d√©velopper des applications Symfony. D√Ætes adieu √† la Standard Edition et bonjour aux tout nouveau symfony/skeleton, Symfony Flex et les recettes qui vont avec.

Vous avez dit Flex ?
D‚Äôun point de vue technique, Symfony Flex est juste un plugin Composer. Il se branche sur les √©v√©nements Composer d√®s lors que vous lancez une commande qui installe, met √† jour ou supprime un paquet PHP ou bundle Symfony. Son but ? Automatiser l‚Äôinstallation et la suppression de vos d√©pendances en fournissant une configuration par d√©faut sans avoir √† aller lire la doc pour trouver quelle configuration √©crire, quelles routes charger ou autre t√¢che r√©barbative √† effectuer. Et d√®s Symfony 4.0, Flex sera le moyen par d√©faut pour d√©velopper une application Symfony.

Il para√Æt qu‚Äôun bon exemple vaut mieux qu‚Äôun long discours. Alors imaginons que vous ayez une application existante en Symfony 3.3 (parce que vous √™tes un dev cool et avez effectu√© les migrations vers les derni√®res versions de Symfony au fur et √† mesure üí™). Vous voulez y ajouter une API en installant api-platform. Vous allez donc effectuer les t√¢ches suivantes :
	
	
Sources : https://afsy.fr/avent/2017/08-symfony-flex-la-nouvelle-facon-de-developper-avec-symfony


WebPack Encore : 
https://symfony.com/doc/current/frontend.html
	





